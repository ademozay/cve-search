package main

import (
	"fmt"
	"strconv"
	"strings"
)

type VulnerabilitySearch struct {
	cve     CVE
	cpeSpec string
}

func NewVulnerabilitySearch(cve CVE, cpeSpec string) *VulnerabilitySearch {
	return &VulnerabilitySearch{
		cve:     cve,
		cpeSpec: cpeSpec,
	}
}

func (vs *VulnerabilitySearch) Search(apps []Application) []Application {
	var vulnerableApps []Application

	for _, cveItem := range vs.cve.CVEItems {
		for _, node := range cveItem.Configurations.Nodes {
			for _, cpeMatch := range node.CPEMatch {
				if cpeMatch.Vulnerable {
					cpeParts := strings.Split(cpeMatch.CPE23Uri, ":")
					if len(cpeParts) < 5 { // invalid uri
						continue
					}

					vendor, appName, version := cpeParts[3], cpeParts[4], cpeParts[5]

					for _, app := range apps {
						// if semver then semver version checker
						// if date then date checker
						if app.Is(vendor, appName, version) {
							vulnerableApps = append(vulnerableApps, app)
							continue
						}

						if app.IsAny(vendor, appName) {
							if version == "*" {
								vulnerableApps = append(vulnerableApps, app)
								continue
							}
							if version == "-" { // FIXME: MI ACABA?
								vulnerableApps = append(vulnerableApps, app)
								continue
							}
							if version == app.Version {
								vulnerableApps = append(vulnerableApps, app)
								continue
							}
							if cpeMatch.CPE23Uri == fmt.Sprintf("cpe:%s:a:%s:%s:%s:*:*:*:*:*:*:*", vs.cpeSpec, app.Vendor, app.Name, app.Version) {
								vulnerableApps = append(vulnerableApps, app)
								continue
							}
						}
					}
				}
			}
		}
	}

	return vulnerableApps
}
