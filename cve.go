package main

import (
	"encoding/json"
	"fmt"
	"strings"
)

type CPEMatch struct {
	Vulnerable bool   `json:"vulnerable"`
	CPE23Uri   string `json:"cpe23Uri"`
}

type Node struct {
	Operator string     `json:"operator"`
	CPEMatch []CPEMatch `json:"cpe_match"`
}

type Configurations struct {
	Nodes []Node `json:"nodes"`
}

type CVEDataMeta struct {
	ID string `json:"ID"`
}

type CVEData struct {
	Meta CVEDataMeta `json:"CVE_data_meta"`
}

type CVEItem struct {
	Configurations Configurations `json:"configurations"`
	CVEData        CVEData        `json:"cve"`
}

type CVE struct {
	CVEItems []CVEItem `json:"CVE_Items"`
}

func NewCVE(data []byte) (*CVE, error) {
	var cve CVE
	err := json.Unmarshal(data, &cve)
	if err != nil {
		return nil, err
	}
	return &cve, nil
}

func (cve *CVE) VulnerableApps(apps []Application) []Application {
	var vulnerableApps []Application
	for _, cveItem := range cve.CVEItems {
		for _, node := range cveItem.Configurations.Nodes {
			for _, cpeMatch := range node.CPEMatch {
				if cpeMatch.Vulnerable {
					cpeParts := strings.Split(cpeMatch.CPE23Uri, ":")
					if len(cpeParts) < 5 { // invalid uri
						continue
					}

					vendor, appName, version := cpeParts[3], cpeParts[4], cpeParts[5]

					for _, app := range apps {
						// if semver then semver version checker
						// if date then date checker
						if app.Name == appName && app.Vendor == vendor { // product name checker - lookup
							if version == "*" {
								vulnerableApps = append(vulnerableApps, app)
								continue
							}
							if version == "-" { // FIXME: MI ACABA?
								vulnerableApps = append(vulnerableApps, app)
								continue
							}
							if version == app.Version {
								vulnerableApps = append(vulnerableApps, app)
								continue
							}

							if cpeMatch.CPE23Uri == fmt.Sprintf("cpe:2.3:a:%s:%s:%s:*:*:*:*:*:*:*", app.Vendor, app.Name, app.Version) {
								vulnerableApps = append(vulnerableApps, app)
								continue
							}
						}
					}
				}
			}
		}
	}
	return vulnerableApps
}
