package semver

import (
	"fmt"
	"strconv"
	"strings"

	"github.com/ademozay/cve-search/internal/cve"
	"github.com/ademozay/cve-search/internal/host"
	"github.com/ademozay/cve-search/internal/version"
)

type SemVer struct {
	major      int
	minor      int
	patch      int
	preRelease string
	metadata   string
}

func New(ver string) (*SemVer, error) {
	preRelease := ""
	metadata := ""
	mainVer := ver

	if strings.Contains(ver, "+") {
		splits := strings.Split(ver, "+")
		mainVer = splits[0]
		metadata = splits[1]
	}

	if strings.Contains(mainVer, "-") {
		splits := strings.Split(mainVer, "-")
		mainVer = splits[0]
		preRelease = splits[1]
	}

	parts := strings.Split(mainVer, ".")

	if len(parts) == 2 {
		parts = append(parts, "0")
	}

	if len(parts) != 3 {
		return nil, fmt.Errorf("invalid version")
	}

	major, err := strconv.Atoi(parts[0])
	if err != nil {
		return nil, fmt.Errorf("invalid major version")
	}

	minor, err := strconv.Atoi(parts[1])
	if err != nil {
		return nil, fmt.Errorf("invalid minor version")
	}

	patch, err := strconv.Atoi(parts[2])
	if err != nil {
		return nil, fmt.Errorf("invalid patch version")
	}

	return &SemVer{major, minor, patch, preRelease, metadata}, nil
}

type Checker struct{}

func NewChecker() version.Checker {
	return &Checker{}
}

func (s *Checker) Vulnerable(localApp host.Application, vulApp cve.VulnerableApp) (bool, error) {
	currVer, err := New(localApp.Version)
	if err != nil {
		return false, fmt.Errorf("failed to parse current app version: %w", err)
	}

	if vulApp.VersionStartIncluding != "" {
		vulVerIncluding, err := New(vulApp.VersionStartIncluding)
		if err != nil {
			return false, fmt.Errorf("failed to parse versionStartIncluding: %w", err)
		}

		if CompareVersions(currVer, vulVerIncluding) < 0 {
			return false, nil
		}
	}

	if vulApp.VersionEndIncluding != "" {
		vulVerIncluding, err := New(vulApp.VersionEndIncluding)
		if err != nil {
			return false, fmt.Errorf("failed to parse versionEndIncluding: %w", err)
		}

		if CompareVersions(currVer, vulVerIncluding) > 0 {
			return false, nil
		}
	}

	if vulApp.VersionStartExcluding != "" {
		vulVerExcluding, err := New(vulApp.VersionStartExcluding)
		if err != nil {
			return false, fmt.Errorf("failed to parse versionStartExcluding: %w", err)
		}

		if CompareVersions(currVer, vulVerExcluding) <= 0 {
			return false, nil
		}
	}

	if vulApp.VersionEndExcluding != "" {
		vulVerExcluding, err := New(vulApp.VersionEndExcluding)
		if err != nil {
			return false, fmt.Errorf("failed to parse versionEndExcluding: %w", err)
		}

		if CompareVersions(currVer, vulVerExcluding) >= 0 {
			return false, nil
		}
	}

	if vulApp.Version != "" && vulApp.Version != "*" && vulApp.Version != "-" {
		vulVer, err := New(vulApp.Version)
		if err != nil {
			return false, fmt.Errorf("failed to parse vulApp version: %w", err)
		}

		return CompareVersions(currVer, vulVer) >= 0, nil
	}

	return true, nil
}

func (s *SemVer) same(ver *SemVer) bool {
	return s.major == ver.major &&
		s.minor == ver.minor &&
		s.patch == ver.patch &&
		s.preRelease == ver.preRelease &&
		s.metadata == ver.metadata
}

func CompareVersions(v1, v2 *SemVer) int {
	if v1.same(v2) {
		return 0
	}

	if v1.major != v2.major {
		return v1.major - v2.major
	}

	if v1.minor != v2.minor {
		return v1.minor - v2.minor
	}

	if v1.patch != v2.patch {
		return v1.patch - v2.patch
	}

	if v1.preRelease != "" && v2.preRelease == "" {
		return -1
	} else if v1.preRelease == "" && v2.preRelease != "" {
		return 1
	}

	if v1.preRelease != "" && v2.preRelease != "" {
		v1PreReleaseParts := strings.Split(v1.preRelease, ".")
		v2PreReleaseParts := strings.Split(v2.preRelease, ".")

		for i := 0; i < len(v1PreReleaseParts) && i < len(v2PreReleaseParts); i++ {
			v1PartInt, err1 := strconv.Atoi(v1PreReleaseParts[i])
			v2PartInt, err2 := strconv.Atoi(v2PreReleaseParts[i])

			if err1 == nil && err2 == nil {
				if v1PartInt != v2PartInt {
					return v1PartInt - v2PartInt
				}
			} else {
				if v1PreReleaseParts[i] != v2PreReleaseParts[i] {
					return strings.Compare(v1PreReleaseParts[i], v2PreReleaseParts[i])
				}
			}
		}

		return len(v1PreReleaseParts) - len(v2PreReleaseParts)
	}

	return 0
}
