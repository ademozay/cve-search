package search

import (
	"fmt"

	"github.com/ademozay/cve-search/internal/cve"
	"github.com/ademozay/cve-search/internal/host"
	"github.com/ademozay/cve-search/internal/version"
)

type Search struct {
	versionCheckers map[version.VersionScheme]version.Checker
}

type Result struct {
	VulnerableApps []MatchedApp
	Failures       []error
}

type MatchedApp struct {
	CVEID   string
	Vendor  string
	Name    string
	Version string
}

func New() *Search {
	return &Search{
		versionCheckers: make(map[version.VersionScheme]version.Checker),
	}
}

func (vs *Search) AddVersionChecker(scheme version.VersionScheme, versionChecker version.Checker) {
	vs.versionCheckers[scheme] = versionChecker
}

func (vs *Search) AddFallbackVersionChecker(versionChecker version.Checker) {
	vs.versionCheckers[version.SchemeNone] = versionChecker
}

func (vs *Search) Search(vulApps []cve.VulnerableApp, localApps []host.Application) *Result {
	var result = &Result{}

localAppLoop:
	for _, localApp := range localApps {
		for _, vulApp := range vulApps {
			if !localApp.Any(vulApp) {
				continue
			}

			versionScheme := version.Scheme(
				vulApp.Version,
				vulApp.VersionStartIncluding,
				vulApp.VersionStartExcluding,
				vulApp.VersionEndIncluding,
				vulApp.VersionEndExcluding,
			)

			versionChecker := vs.versionCheckers[versionScheme]

			if versionChecker == nil {
				fmt.Printf("no version checker found for %v\n", versionScheme)
				continue
			}

			vulnerable, err := versionChecker.Vulnerable(localApp, vulApp)
			if err != nil {
				result.Failures = append(result.Failures, fmt.Errorf("failed to check version for %v: %w", localApp, err))
				continue
			}

			if vulnerable {
				app := MatchedApp{
					CVEID:   vulApp.ID,
					Vendor:  localApp.Vendor,
					Name:    localApp.Name,
					Version: localApp.Version,
				}
				result.VulnerableApps = append(result.VulnerableApps, app)
				continue localAppLoop
			}
		}
	}

	return result
}
