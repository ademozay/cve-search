package vulnerability

import (
	"fmt"
	"strings"

	"github.com/ademozay/vmetric/internal/cve"
	"github.com/ademozay/vmetric/internal/host"
	"github.com/ademozay/vmetric/internal/version"
)

type VulnerabilitySearch struct {
	cve             cve.CVE
	cpeSpec         string
	versionCheckers []version.VersionChecker
}

func NewSearch(cve cve.CVE, cpeSpec string) *VulnerabilitySearch {
	return &VulnerabilitySearch{
		cve:     cve,
		cpeSpec: cpeSpec,
	}
}

func (vs *VulnerabilitySearch) AddVersionChecker(vc version.VersionChecker) {
	if vc != nil {
		vs.versionCheckers = append(vs.versionCheckers, vc)
	}
}

func (vs *VulnerabilitySearch) Search(apps []host.Application) []host.Application {
	var vulnerableApps []host.Application

	for _, cveItem := range vs.cve.CVEItems {
		for _, node := range cveItem.Configurations.Nodes {
		matchLoop:
			for _, cpeMatch := range node.CPEMatch {
				if cpeMatch.Vulnerable {
					cpeParts := strings.Split(cpeMatch.CPE23Uri, ":")
					if len(cpeParts) < 5 { // invalid uri
						continue matchLoop
					}

					vulApp := host.Application{
						Vendor:  cpeParts[3],
						Name:    cpeParts[4],
						Version: cpeParts[5],
					}

				appLoop:
					for _, app := range apps {
						if cpeMatch.CPE23Uri == fmt.Sprintf("cpe:%s:a:%s:%s:%s:*:*:*:*:*:*:*", vs.cpeSpec, app.Vendor, app.Name, app.Version) {
							vulnerableApps = append(vulnerableApps, app)
							continue appLoop
						}

						if app.IsAny(vulApp) {
							for _, vc := range vs.versionCheckers {
								if vc.Vulnerable(app, vulApp, cpeMatch.VersionStartIncluding, cpeMatch.VersionEndIncluding, cpeMatch.VersionStartExcluding, cpeMatch.VersionEndExcluding) {
									vulnerableApps = append(vulnerableApps, app)
									continue appLoop
								}
							}
						}
					}
				}
			}
		}
	}

	return vulnerableApps
}
